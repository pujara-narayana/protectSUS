"""Vulnerability Assessment Agent (VAA)"""

from typing import Dict, Any
import logging

from app.services.agents.base_agent import BaseAgent
from app.models.analysis import Vulnerability

logger = logging.getLogger(__name__)


class VulnerabilityAgent(BaseAgent):
    """Agent for detecting security vulnerabilities in code"""

    def __init__(self, llm_provider: str = None):
        super().__init__("VulnerabilityAgent", llm_provider=llm_provider)

    async def analyze(self, code: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Analyze code for security vulnerabilities

        Detects: SQL injection, XSS, CSRF, authentication issues,
        authorization flaws, sensitive data exposure, etc.
        """
        logger.info(f"{self.name}: Starting vulnerability analysis")

        system_prompt = """You are a world-class code reviewer, security researcher, and senior software engineer with 20+ years of experience.

Your mission is to perform an EXHAUSTIVE analysis of the provided codebase to find ALL issues that could:
- Break the build or prevent deployment
- Cause runtime crashes or errors
- Create security vulnerabilities
- Lead to data loss or corruption
- Cause performance problems

## CATEGORY 1: BUILD-BREAKING ISSUES (CRITICAL - Check First!)
- Syntax errors (missing brackets, semicolons, colons, quotes)
- Invalid language constructs
- Import/require errors (missing modules, typos in imports)
- Circular dependencies
- Missing required files or configurations
- Invalid JSON/YAML/config file syntax
- Incompatible language version features
- Missing environment variables that are required
- Invalid file paths or references

## CATEGORY 2: RUNTIME ERRORS (HIGH Priority)
- Null/undefined reference errors (accessing properties on null)
- Type mismatches (passing wrong types to functions)
- Array/index out of bounds
- Division by zero
- Unhandled promise rejections
- Missing error handling (try/catch blocks)
- Async/await misuse
- Unclosed resources (files, connections, streams)
- Memory leaks
- Infinite loops or recursion without base case
- Race conditions and deadlocks
- Incorrect API usage

## CATEGORY 3: LOGIC ERRORS (HIGH Priority)
- Off-by-one errors
- Wrong comparison operators (= vs ==, == vs ===)
- Incorrect boolean logic
- Missing return statements
- Unreachable code
- Variable shadowing causing bugs
- Incorrect function signatures
- Wrong variable used (copy-paste errors)
- Incorrect loop conditions
- Missing break/continue statements
- Incorrect exception handling

## CATEGORY 4: SECURITY VULNERABILITIES (OWASP Top 10)
- SQL/NoSQL Injection
- Cross-Site Scripting (XSS)
- Cross-Site Request Forgery (CSRF)
- Broken Authentication
- Sensitive Data Exposure (hardcoded secrets, API keys, passwords)
- Security Misconfiguration
- Insecure Direct Object References
- Missing Access Control
- Command Injection
- Path Traversal
- XML External Entities (XXE)
- Insecure Deserialization
- Server-Side Request Forgery (SSRF)
- Insufficient Input Validation

## CATEGORY 5: CODE QUALITY ISSUES (MEDIUM Priority)
- Deprecated API/function usage
- Anti-patterns
- Missing input validation
- Hardcoded values that should be configurable
- Missing logging for error conditions
- Incorrect error messages
- Missing documentation for complex logic

## OUTPUT FORMAT (STRICT - Follow Exactly):
For EACH issue found, output:

FILE: [exact file path from the code]
LINE: [line number or range like 10-15]
SEVERITY: [critical|high|medium|low]
TYPE: [e.g., SYNTAX_ERROR, NULL_REFERENCE, SQL_INJECTION, TYPE_MISMATCH, etc.]
CWE: [CWE-XXX if applicable, otherwise N/A]
DESCRIPTION: [Clear explanation of what's wrong and why it's a problem]
IMPACT: [What will happen if this isn't fixed - be specific]
FIX: [Exact code fix or clear instructions]

## RULES:
1. Be THOROUGH - find EVERY issue, even small ones
2. Prioritize CRITICAL and HIGH severity first
3. Include the EXACT file path and line number
4. Provide ACTIONABLE fixes, not vague suggestions
5. If you're uncertain about severity, err on the side of caution (higher severity)
6. Check for issues across ALL files, not just the first few"""

        user_prompt = f"""Perform a COMPREHENSIVE code review on this codebase. Find ALL issues - syntax errors, runtime bugs, logic errors, and security vulnerabilities.

## CODE TO ANALYZE:
{code}

## CONTEXT:
- Repository: {context.get('repo_full_name', 'unknown')}
- Files analyzed: {context.get('file_mapping', {}).get('total_files', 'unknown')}
- Compression ratio: {context.get('compression_ratio', 0):.1%}

## YOUR TASK:
1. FIRST: Scan for syntax errors and import issues that will break the build
2. SECOND: Look for runtime errors (null references, type errors, unhandled exceptions)
3. THIRD: Check for logic errors and bugs
4. FOURTH: Assess security vulnerabilities
5. FIFTH: Note any code quality issues

## IMPORTANT:
- Check EVERY file in the codebase
- Report ALL issues you find, even minor ones
- Be specific with file paths and line numbers
- Provide concrete, actionable fixes
- If no issues found, explicitly state "NO ISSUES FOUND"

Output your findings in the specified format. Start with CRITICAL issues, then HIGH, then MEDIUM, then LOW."""

        try:
            # Call LLM API
            response = await self._call_llm(system_prompt, user_prompt)

            # Extract structured findings
            findings = self._extract_findings(response, 'vulnerability')

            # Convert to Vulnerability models
            vulnerabilities = []
            for finding in findings:
                if all(k in finding for k in ['file_path', 'line_number', 'severity', 'type']):
                    try:
                        vuln = Vulnerability(
                            type=finding['type'],
                            severity=finding['severity'],
                            file_path=finding['file_path'],
                            line_number=finding['line_number'],
                            description=finding.get('description', ''),
                            cwe_id=finding.get('cwe_id'),
                            recommended_fix=finding.get('recommended_fix')
                        )
                        vulnerabilities.append(vuln)
                    except Exception as e:
                        logger.warning(f"Failed to create Vulnerability from finding: {e}")

            logger.info(f"{self.name}: Found {len(vulnerabilities)} vulnerabilities")

            return {
                'agent_name': self.name,
                'vulnerabilities': [v.model_dump() for v in vulnerabilities],
                'raw_response': response,
                'findings_count': len(vulnerabilities)
            }

        except Exception as e:
            logger.error(f"{self.name}: Analysis failed: {e}")
            raise
