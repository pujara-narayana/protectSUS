"""Vulnerability Assessment Agent (VAA)"""

from typing import Dict, Any
import logging

from app.services.agents.base_agent import BaseAgent
from app.models.analysis import Vulnerability

logger = logging.getLogger(__name__)


class VulnerabilityAgent(BaseAgent):
    """Agent for detecting security vulnerabilities in code"""

    def __init__(self, llm_provider: str = None):
        super().__init__("VulnerabilityAgent", llm_provider=llm_provider)

    async def analyze(self, code: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Analyze code for security vulnerabilities

        Detects: SQL injection, XSS, CSRF, authentication issues,
        authorization flaws, sensitive data exposure, etc.
        """
        logger.info(f"{self.name}: Starting vulnerability analysis")

        system_prompt = """You are an expert security researcher and software engineer specializing in application security, code analysis, and error detection.

Your task is to analyze the provided code for:

**SECURITY VULNERABILITIES (OWASP Top 10 & CWE):**
1. Injection flaws (SQL, NoSQL, Command, LDAP, XPath)
2. Cross-Site Scripting (XSS) - reflected, stored, DOM-based
3. Cross-Site Request Forgery (CSRF)
4. Broken Authentication and Session Management
5. Security Misconfiguration
6. Sensitive Data Exposure
7. Missing Access Control
8. XML External Entities (XXE)
9. Insecure Deserialization
10. Using Components with Known Vulnerabilities

**CRITICAL CODE ISSUES:**
11. Syntax errors that will prevent compilation/execution
12. Type errors and type mismatches
13. Import errors (missing modules, circular dependencies)
14. Undefined variables or functions
15. Breaking changes (API changes, deprecated method usage)
16. Runtime errors (null pointer/undefined, array bounds, divide by zero)
17. Logic errors that cause incorrect behavior
18. Resource leaks (unclosed files, connections, memory leaks)
19. Concurrency issues (race conditions, deadlocks)
20. Build/compilation breaking issues

**PRIORITY:** Flag CRITICAL and HIGH severity issues first - these are showstoppers that will break the application.

For each issue found, provide output in this EXACT format:

FILE: [file path]
LINE: [line number]
SEVERITY: [critical|high|medium|low]
TYPE: [issue type, e.g., SQL_INJECTION, SYNTAX_ERROR, TYPE_ERROR, RUNTIME_ERROR]
CWE: [CWE-XXX if security issue, or N/A]
DESCRIPTION: [detailed description of the issue and its impact]
FIX: [recommended fix with code example if applicable]

Be thorough and prioritize issues that will break the codebase or cause immediate failures."""

        user_prompt = f"""Analyze this codebase for security vulnerabilities AND critical code issues that will break the application:

{code}

Repository context:
- Files analyzed: {context.get('file_mapping', {}).get('total_files', 'unknown')}
- Compressed: {context.get('compression_ratio', 0):.1%}

**IMPORTANT:** 
1. Check for syntax errors, type errors, and undefined references first
2. Look for breaking changes and deprecated API usage
3. Identify runtime errors and edge cases
4. Then assess security vulnerabilities

Provide detailed findings following the specified format, prioritizing CRITICAL severity issues."""

        try:
            # Call LLM API
            response = await self._call_llm(system_prompt, user_prompt)

            # Extract structured findings
            findings = self._extract_findings(response, 'vulnerability')

            # Convert to Vulnerability models
            vulnerabilities = []
            for finding in findings:
                if all(k in finding for k in ['file_path', 'line_number', 'severity', 'type']):
                    try:
                        vuln = Vulnerability(
                            type=finding['type'],
                            severity=finding['severity'],
                            file_path=finding['file_path'],
                            line_number=finding['line_number'],
                            description=finding.get('description', ''),
                            cwe_id=finding.get('cwe_id'),
                            recommended_fix=finding.get('recommended_fix')
                        )
                        vulnerabilities.append(vuln)
                    except Exception as e:
                        logger.warning(f"Failed to create Vulnerability from finding: {e}")

            logger.info(f"{self.name}: Found {len(vulnerabilities)} vulnerabilities")

            return {
                'agent_name': self.name,
                'vulnerabilities': [v.model_dump() for v in vulnerabilities],
                'raw_response': response,
                'findings_count': len(vulnerabilities)
            }

        except Exception as e:
            logger.error(f"{self.name}: Analysis failed: {e}")
            raise
